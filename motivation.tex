
\section{Motivation and Goals}

Over the last years, significant progress has been made both on static and runtime program verification techniques, focusing on increasing the quality of software\footnote{We use the terms static and runtime verification. The terms static and dynamic analysis are often used instead, and we shall occasionally use these terms.}. Within this track, we would like to investigate how we can leverage these techniques by combining them. Questions that will be addressed are for example: what can static verification  bring to runtime verification 
to reduce impact on execution time and memory use, and what can runtime verification bring to static verification to take over where static verification fails to either scale or provide precise results. One can to some extent consider these two views (static verification supporting runtime verification, and runtime verification supporting static verification) as fundamentally representing the same scenario: prove what can be proved statically, and dynamically analyze the rest. 

The session will consist of several presentations, some on the individual techniques, and some on experiences combining the two techniques. When preparing this session, we aimed at finding a balance between static and runtime verification backgrounds of the presenters. This is also reflected by the papers associated to this track. There are several papers describing systems that first attempt to verify as much as possible by static verification, and then use runtime verification for the properties that cannot be verified statically. There is another group of papers that use static program information to generate appropriate run-time checks. Finally, a last group of papers discuss program specification techniques from static verification, and how they can be made suitable for runtime verification, or the other way round.

During the conference, three panel discussions on this topic are planned. The first panel focuses on static verification. What does it need, and what can it bring to runtime verification? The second panel focuses on the opposite question: what does runtime verification need, and what can it bring to static static verification? The last panel  discusses future research directions in this area, and what are the most promising ideas for combining static and runtime verification. Concrete topics that will be discussed include the limitations and benefits of each approach, how we can combine efforts to benefit verification, what are the overheads/benefits of combining efforts, industrial application in each area, industrial needs, etc.



%\kla{This section should be longer.}